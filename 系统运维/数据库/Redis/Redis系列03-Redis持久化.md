# Redis数据持久化
* 说明
```
1. 由于Redis中的数据都存储在内存中，当redis重启后，所有的数据就会丢失，由于某些原因，我们希望redis中的数据在重启后也不会丢失，如redis作为数据库使用或者是redis作为缓存使用，如果所有的缓存都同时失效，则会引起缓存雪崩，导致后端服务器无法使用。
2. 这种情况下，我们希望将内存中的数据保存在硬盘上，使得redis在重启后，可以根据硬盘中的记录进行数据恢复。这就是数据持久化。

redis支持两种方式的持久化：RDB和AOF。
    RDB：Redis Database，会根据指定的规则，"定时"将内存中的数据存储在硬盘上。
    AOF：Append Only File，在每次执行命令后，将命令本身记录下来。

    上述两者可以单独使用其中一种，更多情况下是两者结合使用。
```

# RDB
## 执行快照的条件
```
RDB方式的持久化，是通过快照(Snapshotting)完成的。
当符合一定条件时，redis会自动将内存中的所偶有数据生成一份副本并保存在硬盘上，这个过程称为快照。

Redis对数据做快照的条件：
1. 根据配置规则进行自动快照。
2. 用户执行SAVE或BGSAVE命令。
3. 执行FLUSHALL命令。
4. 执行复制(Replication)时。
```

* 根据配置规则进行自动快照
```
redis允许用户自定义快照条件，当符合快照条件时，redis会自动执行快照操作。

快照条件在redis的配置文件中通过save命令定义。该指令由两个参数组成：时间窗口M和改动的键的个数N。

每当时间M(单位是秒)内被更改的键的个数大于N时，就符合自动快照条件。

默认配置(多个条件之间是或的关系)：
save 900 1      # 900秒后至少有一个键被更改
save 300 10     # 300秒后至少有10个键被更改
save 60 10000   # 60秒后至少有10000个键被更改
```

* 执行SAVE或BGSAVE命令
```
1. SAVE命令
当执行SAVE命令时，Redis同步地进行快照操作，在快照执行过程中会阻塞所有来自客户端的请求。
当数据库中的数据比较多时，这一过程会导致Redis较长时间不响应。
生产环境中尽量避免使用这一命令。

SAVE操作是在父进程中进行快照操作的，由于redis是用一个主进程来处理客户端的请求的，所有在使用SAVE命令时，会阻塞所有客户端的请求。

2. BGSAVE命令
需要手动执行快照时，推荐使用BGSAVE命令。
BGSAVE命令可以在后台异步地进行快照操作，快照的同时还可以继续响应客户端的请求。
执行BGSAVE后Redis会立即返回OK表示开始执行快照操作，如果想知道快照是否完成，可以通过LASTSAVE命令获取最近一次成功执行快照的时间。结果返回的是一个Unix时间戳。

127.0.0.1:6379> BGSAVE
Background saving started
127.0.0.1:6379>
127.0.0.1:6379> LASTSAVE
(integer) 1482302424
127.0.0.1:6379>
```

* 指定FLUSHALL命令
```
当执行FLUSHALL时，Redis会清除数据库(所有数据库)中的所有数据。
注意：不论清空数据库的过程是否触发了自动快照条件，只要自动快照条件不为空，Redis就会执行一次快照操作。

当没有定义自动快照条件时，执行FLUSHALL则不会进行快照。
```

* 执行复制时
```
当设置了主从模式时，Redis会在复制初始化时进行自动快照。

当使用复制操作时，即使没有定义自动快照条件，并且没有手动执行过快照操作，也会生成RDB快照文件。
```

## 快照原理
```
redis默认会将快照文件存储在redis当前工作进程的工作目录中的dump.rdb文件中，可以通过配置文件中的dir和dbfilename命令指定快照文件的存储路径和快照文件的文件名。

快照过程如下：
1. Redis使用fork函数复制一份当前进程(父进程)的副本(子进程)。
2. 父进程继续接受并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件。
3. 当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完成。

```

>注意：
>在执行fork的时候操作相同(类Unix操作系统)会使用写时复制(copy-on-write)策略，即fork函数发生的那一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时(如执行一个写命令)，操作系统会将该片数据复制一份以保证子进程的数据不受影响，所有新的RDB文件存储的是执行fork那一刻的内存数据。
>
>另外注意的是，如果写入操作过多，造成fork前后的数据差异较大，是会使得内存使用量显著超过实际数据大小的，因为内存中不仅保存了当前的数据库数据，而且还保存着fork时刻的内存数据。

```
RDB文件是经过压缩的二进制格式(可以配置rdbcompression参数禁用压缩节省CPU占用)，所以占用的空间会小于内存中的数据大小，更加利于传输。
默认值：rdbcompression yes

Redis启动后会读取RDB文件，将数据从硬盘载入到内存。

通过RDB实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。
```

# AOF
```
AOF可以将Redis执行的每一条命令追加到硬盘文件中，这一过程显然会降低Redis性能，使用较快的硬盘可以提高Redis性能。
```

* 开启AOF
```
默认情况下，AOF(Append Only File)是没有开启的，可以通过appendonly参数启用。
启用：appendonly yes

当启用AOF后，每执行一条会更改Redis中的数据的命令，redis就会将该命令写入到硬盘中的AOF文件。
AOF文件保存位置和RDB文件的位置相同，都是通过dir参数设置的。默认的文件名是appendonly.aof。
定义文件名：appendfilename "appendonly.aof"
```

```
有时，AOF文件中记录的命令可能是冗余的，希望redis自动对AOF文件进行优化，可以在配置文件中进行如下配置，当达到一定条件时，就对AOF进行重写：
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

说明：
auto-aof-rewrite-percentage：表示的是当目前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写。如果之前没有重写过，则以启动时的AOF文件大小为依据。
auto-aof-rewrite-min-size：设置允许重写的最小AOF文件的大小，通常在AOF文件很小的情况下即使其中有很多冗余的命令，我们也并不太关心。

手动执行AOF重写：BGREWRITEAOF
```

```
在启动Redis时，会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存，载入的速度要比RDB慢。
因为要执行命令重放。
```

* 同步硬盘数据
```
虽然每次执行更改数据库内容的操作时，AOF都会将命令记录在AOF文件中，事实上，由于操作相同的缓存机制，数据并没有真正的写入硬，而是保存在硬盘缓存中。

默认情况下，系统每30s会执行一次同步操作，以便将硬盘缓存中的内容真正的写入硬盘。
在这30s的过程中，如果系统异常退出则会导致硬盘缓存中的数据丢失。

设置同步时间间隔：
# appendfsync always：每一次写操作都会立即写入硬盘，性能最差，数据最安全。
appendfsync everysec：一秒一次将数据写入到硬盘。在性能和数据安全方面折中的一种，推荐。
# appendfsync no：不调用fsync，完全依赖于操作系统，在需要的时候才将数据写入到硬盘。依然会导致数据丢失。性能最好。

```

```
如果同时启用了RDB和AOF，则redis启动时，采用AOF的方式恢复数据。因为AOF的方式丢失的数据最少。
```