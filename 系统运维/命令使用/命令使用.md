# seq命令
```text
语法格式：
seq [OPTION]... LAST
seq [OPTION]... FIRST LAST
seq [OPTION]... FIRST INCREMENT LAST

选项：
-w：等宽输出。
-s：指定输出分隔符。默认为换行
-f：以printf的格式输出。
```

```bash
示例1：
[root@vm10 tmp]# seq -f 'file%03g' -s ' ' 1 5
file001 file002 file003 file004 file005
[root@vm10 tmp]# 


示例2：
[root@vm10 tmp]# seq -w 5 5 15
05
10
15
[root@vm10 tmp]# 

示例3：
[root@vm10 tmp]# seq -w -s ' - ' 5 5 15
05 - 10 - 15
[root@vm10 tmp]# 
```

# nohup命令
```text
nohup可以将程序以忽略挂起信号的方式运行起来，被运行的程序的输出将不会显示到终端。通常情况下，当我们以后台的方式（&）运行一个程序，这个程序通常是和当前shell终端相关联的，当我们的shell终端非法关闭（如ssh远程登录断开），系统会向和该终端所关联的所有进程发送SIGHUP信号，如果进程无法处理该信号，则默认就是终止进程。当使用nohup运行程序时，如果和该进程相关的终端关闭后，则该进程的父进程自动和init进程相关联（init的进程ID为1），这样只有当系统重启时，该进程才会终止。

无论是否将nohup命令的输出重定向到终端，输出都会附加到当前目录下的nohup.out文件中，如果当前目录的nohup.out文件不可写，则将输出重定向到$HOME/nohup.out文件中。如果没有文件能创建或可以追加，则nohup后面的命令将不可执行。
```

```bash
示例1：
# nohup sh check_ssh_login.sh &

示例2：指定输出文件。
# nohup sh check_ssh_login.sh > test.txt 2>&1 &
```

# find文件查找
```text
find语法格式：
find 查找路径  查找标准  查找到以后的处理动作
说明：
查找路径：默认为当前目录。
查找标准：默认为指定路径下的所有文件。
处理动作：默认为显示。

查找标准有：
-name 'filename'：根据文件名查找，精确查找。区分大小写。
-iname 'filename'：文件名匹配不区分大小写。
    文件名通配符：
     *：匹配任意长度的任意字符。
     ?：匹配任意一个字符。
     []：匹配括号中的任意一个字符。

-regex：使用正则表达式匹配文件名，区分大小写。
-iregexp：使用正则表达式匹配文件名，不区分大小写。

-user：根据文件的拥有者进行查找。
-group：根据文件的属组进行查找。
-uid：根据uid查找。
-gid：根据gid查找。
-nouser：查找没有属主的文件。
-nogroup：查找没有属组的文件。

-type：根据文件类型查找。
    f:普通文件
    d:目录
    b:块设备文件
    c:字符设备文件
    s：socket文件
    p：pipe管道文件
    l：链接文件

-size [[+-]nk|M|G]：根据文件大小查找。如果没有跟上大小，则默认单位为字节。+：表示大于指定的单位，-：表示小于指定大小的文件。

组合条件：
    -a：与
    -o：或
    -not：非
    如果指定了多个找到文件，但是没有指定组合条件，则默认为-a。

-mtime [[+-]n]：修改时间，文件内容被修改
-ctime [[+-]n]：改变时间，文件属性被修改
-atime [[+-]n]：访问时间，文件被查看
上述n为天数。
 
-mmin [[+-]n]
-cmin [[+-]n]
-amin [[+-]n]
上述n表示的是分钟。
 
+n     for greater than n
-n     for less than n
n      for exactly n
说明：如果时间为+5，则表示5天/分钟前。如果为-5，则表示5天/分钟内，如果为5，则表示第五天/分钟这一天。
 
-perm MODE：根据文件的权限匹配。确切的匹配权限，必须为指定的权限。
-perm -MODE：mode中的所有权限位都必须要设置才满足条件。
-perm /MODE：mode中的任何一个权限位被设置都满足条件。
 
 
find的动作
-print：默认的动作。
-ls：类似于ls -l的形式显示每一个文件的详细信息。
-ok COMMAND {} \; ：要执行的动作，和-exec一样的。{}表示引用找到的文件。\;结束符，为固定格式。
-exec COMMAND {} \; ：要执行的动作。

说明：-ok和-exec的区别是，-ok需要对每一个动作进行确认，-exec不需要确认。
```

# FACL(Filesystem Access Control List)
```text
setfacl: 设置文件或目录的ACL信息

说明：当文件具有扩展的属性时，使用ls -l列出文件的权限时，会看到有个加号（+）

选项：
-m：设置额外的ACL信息。
    u:USER:perm
    g:GROUP:perm
    o:OTHER:perm
    m:MASK
-x：取消设置额外的ACL信息。
    u:USER
    g:GROUP
    o:OTHER
    m:MASK

设置默认的ACL（只能用于目录），当为目录设置ACL时，在该目录下创建的文件自动会继承目录的ACL信息。
    d:u:USER:perm
    d:g:GROUP:perm

-b：移除所有的扩展ACL规则。
-k：移除默认的ACL规则。

-R：递归对所有文件及目录进行设置。
--restore=file：对ACL进行恢复。（备份可以用getfacl -R）

getfacl：获取文件或目录的ACL信息
    
-R：对acl进行备份。

```


```bash
示例1：设置facl
[root@vm10 tmp]# setfacl -m u:felix:rw- check_ssh_login.sh 
[root@vm10 tmp]# getfacl check_ssh_login.sh
# file: check_ssh_login.sh
# owner: root
# group: root
user::rw-
user:felix:rw-
group::r--
mask::rw-
other::r--

[root@vm10 tmp]#

示例2：取消设置
[root@vm10 tmp]# setfacl -x u:felix check_ssh_login.sh
[root@vm10 tmp]# getfacl check_ssh_login.sh
# file: check_ssh_login.sh
# owner: root
# group: root
user::rw-
group::r--
mask::r--
other::r--

[root@vm10 tmp]# 

示例3：acl备份和恢复
[root@vm10 tmp]# setfacl -m u:felix:rwx nohup.out 
[root@vm10 tmp]# getfacl nohup.out 
# file: nohup.out
# owner: root
# group: root
user::rw-
user:felix:rwx
group::---
mask::rwx
other::---

[root@vm10 tmp]# getfacl -R nohup.out > acl_backup.txt
[root@vm10 tmp]# setfacl -b nohup.out 
[root@vm10 tmp]# getfacl nohup.out 
# file: nohup.out
# owner: root
# group: root
user::rw-
group::---
other::---

[root@vm10 tmp]# setfacl --restore=acl_backup.txt 
[root@vm10 tmp]# getfacl nohup.out 
# file: nohup.out
# owner: root
# group: root
user::rw-
user:felix:rwx
group::---
mask::rwx
other::---

[root@vm10 tmp]# 

```

# df(显示磁盘空间的使用情况)
```text
选项：
-a：显示所有的文件系统，包括伪文件系统。
-h：以人类可读的方式显示文件大小。
-i：显示inode的使用情况
-T：显示文件系统类型。
-P：使用POSIX风格的输出。
```

# mknod(创建一个设备文件)
```text
设备文件介绍

设备文件分为：块设备(b)、字符设备(c)。每一个设备文件都有Major(主设备号)和Minor(次设备号)。Major代表的是不同类型的设备，Minor代表的是同一类型的多个设备。所有的设备文件都位置/dev目录下。

mknod是用于创建一个块设备文件或字符设备文件。

语法格式：mknod 选项  NAME TYPE  [MAJOR MINOR]
选项：
-m：设置权限模式。类似于chmod。

NAME：表示要创建的设备的文件名。
TYPE：表示要创建的设备类型。b表示块设备文件，c表示字符设备文件
MAJOR：指定设备文件的主设备号。
MINOR：指定设备文件的次设备号。

```
```bash
示例1：
[root@vm10 tmp]# mknod -m 660 /dev/sda100 b 8 100
[root@vm10 tmp]# ls -l /dev/sda100
brw-rw---- 1 root root 8, 100 Aug 12 13:49 /dev/sda100
[root@vm10 tmp]# chown root:disk /dev/sda100
[root@vm10 tmp]# ls -l /dev/sda100
brw-rw---- 1 root disk 8, 100 Aug 12 13:49 /dev/sda100
[root@vm10 tmp]# 

示例2：给终端发送信息
查看当前终端：tty

[root@vm10 tmp]# cat >> /dev/pts/1 << EOF
你是谁？
为什么在我的系统上
请退出
谢谢
EOF
[root@vm10 tmp]# 

```

# 磁盘相关的命令
## 磁盘分区命令
```text
磁盘分区：fdisk和parted

fdisk命令使用：fdisk /dev/sdb
常用的fdisk子命令如下：
a：设置可引导标记
d：删除一个分区
p：查看分区信息
n：新建一个分区
m：查看帮助信息
l：列出磁盘分区类型
t：修改磁盘分区类型
q：不保存退出
w：保存退出

当使用fdisk命令分区后，查看/proc/partitions，如果内核已经识别了新创建的分区的话，则可以直接格式化，否则的话，需要让内核识别出这个新的分区，解决方法如下：
1. 重启系统。
2. 使用partprobe命令，让操作系统内核重读分区表。
3. 使用partx命令。

查看内核识别出的分区信息：/proc/partitions 
[root@vm10 ~]# cat /proc/partitions 
major minor  #blocks  name

   8        0   20971520 sda
   8        1     204800 sda1
   8        2   20765696 sda2
   8       16   10485760 sdb
 253        0   18665472 dm-0
 253        1    2097152 dm-1
[root@vm10 ~]# 
```

## partx(让内核重读分区表)
```text
partx：用来告诉内核当前磁盘分区情况。和fdisk不一样。
语法：partx 选项 [partition] wholedisk

选项：
-a：添加指定的磁盘分区或者是读整个硬盘，添加所有分区。
-d：删除指定分区或者所有分区。
-l：列出磁盘分区。
```

```bash
示例：
注意：内核必须要识别出新的分区，才能够格式化

1. 使用fdisk /dev/sdb创建了3个分区。
[root@vm10 ~]# fdisk -l /dev/sdb

Disk /dev/sdb: 10.7 GB, 10737418240 bytes
255 heads, 63 sectors/track, 1305 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x4b81ea63

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1         132     1060258+  83  Linux
/dev/sdb2             133         264     1060290   83  Linux
/dev/sdb3             265         396     1060290   83  Linux
[root@vm10 ~]# 

2. 查看内核识别出的分区信息
[root@vm10 ~]# cat /proc/partitions 
major minor  #blocks  name

   8        0   20971520 sda
   8        1     204800 sda1
   8        2   20765696 sda2
   8       16   10485760 sdb
 253        0   18665472 dm-0
 253        1    2097152 dm-1
[root@vm10 ~]# 

3. 让内核重读分区表
[root@vm10 ~]# partx -a /dev/sdb
[root@vm10 ~]# 

4. 查看内核识别出的分区信息
[root@vm10 ~]# cat /proc/partitions 
major minor  #blocks  name

   8        0   20971520 sda
   8        1     204800 sda1
   8        2   20765696 sda2
   8       16   10485760 sdb
   8       17    1060258 sdb1
   8       18    1060290 sdb2
   8       19    1060290 sdb3
 253        0   18665472 dm-0
 253        1    2097152 dm-1
[root@vm10 ~]# 

已经识别出来新创建的3个分区。

5. 格式化
[root@vm10 ~]# mkfs -t ext4 /dev/sdb1
mke2fs 1.41.12 (17-May-2010)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
66384 inodes, 265064 blocks
13253 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=272629760
9 block groups
32768 blocks per group, 32768 fragments per group
7376 inodes per group
Superblock backups stored on blocks: 
    32768, 98304, 163840, 229376

Writing inode tables: done                            
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 26 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
[root@vm10 ~]# 

6. 挂载
[root@vm10 ~]# mkdir /mount-test
[root@vm10 ~]# mount /dev/sdb1 /mount-test/
[root@vm10 ~]# cd /mount-test/
[root@vm10 mount-test]# ls
lost+found
[root@vm10 mount-test]# df -h
Filesystem                   Size  Used Avail Use% Mounted on
/dev/mapper/vg_root-root_lv   18G  1.3G   16G   8% /
tmpfs                        116M     0  116M   0% /dev/shm
/dev/sda1                    194M   29M  155M  16% /boot
/dev/sdb1                   1020M   34M  935M   4% /mount-test
[root@vm10 mount-test]# 

```

## mkfs创建文件系统(分区格式化)
```
mkfs的语法格式：mkfs 选项  filesys

选项：
-t：指定文件系统类型，如ext3、ext4、xfs等。

如：mkfs -t ext4 /dev/sdb1

说明：当我们使用mkfs命令创建文件系统时，实际上是调用了mkfs.ext4/mkfs.ext3/mkfs.xfs之类的命令创建文件系统。也可以直接使用mkfs.ext4这样的命令直接创建文件系统。
```

## mke2fs(创建ext*之类的文件系统)
```
选项：
-t：指定文件系统类型。如ext3、ext4，默认为ext2.
-j：如果没有指定-t选项，使用-j选项的话，则创建ext3文件系统。
-b：指定块大小。可以是1024、2048、4096.
-L：指定卷标（LABEL），默认没有卷标。当指定卷标时，可用用卷标进行挂载。
-m：指定保留块的大小，默认为5%。
-n：并不是真正的创建文件系统，仅仅是用于显示当创建文件系统时，会发生什么，可用于显示备份的超级块的位置，用于超级块恢复。
-S：当超级块和所有备份的超级块损坏时，该选项将会作为最后的一种修复方式。该选项仅仅会重写超级块和GDT信息，不会初始化inode table、block bitmap和inode bitmap。当使用该选项后，应该立即运行e2fsck命令。
-U：使用指定的UUID创建文件系统，否则将使用随机的UUID。产生UUID可以用uuidgen命令。

常用的选项：-t、-b、-m、-L
文件系统修复常用的选项：-n、-S
```

## blkid(显示block设备的属性)
```
作用：用于查询块设备的LABEL、UUID、TYPE等信息。

选项：
-s tag：查询指定设备的tag信息，tag有：UUID、LABEL、TYPE
-o format：使用指定的format输出blkid信息。format如下：
    full:默认选项，打印所有tag。
    value：打印出tag的值。可以结合-s选项，打印出指定tag的值。
    list：以列表的形式显示。
    device：仅仅显示设备名。
-L：根据LABEL过滤设置。
-t NAME=VALUE：根据指定的NAME过滤设备。NAME可以是LABEL、UUID、TYPE

示例1：查询指定设备的信息。
[root@vm10 ~]# blkid /dev/sdb1
/dev/sdb1: LABEL="felix" UUID="2baba457-5d58-449b-bbb8-c97860db85db" TYPE="ext2" 
[root@vm10 ~]# 

示例2：查询指定设备的UUID
[root@vm10 ~]# blkid -s UUID /dev/sdb1
/dev/sdb1: UUID="2baba457-5d58-449b-bbb8-c97860db85db" 
[root@vm10 ~]# 
[root@vm10 ~]# blkid -s UUID -o value /dev/sdb1
2baba457-5d58-449b-bbb8-c97860db85db
[root@vm10 ~]# 

示例3：查询所有设备的设备名
[root@vm10 ~]# blkid -o device
/dev/sda1
/dev/sda2
/dev/sdb1
/dev/mapper/vg_root-root_lv
/dev/mapper/vg_root-swap_lv
[root@vm10 ~]# 
```

## e2label
```
作用：查看或设置ext系列的文件系统的卷标（LABEL）

格式：e2label device [ new-label ]

示例1：查看卷标
[root@vm10 ~]# e2label /dev/sdb1
felix
[root@vm10 ~]# 

示例2：设置卷标
[root@vm10 ~]# e2label /dev/sdb1 data1
[root@vm10 ~]# 
[root@vm10 ~]# e2label /dev/sdb1
data1
[root@vm10 ~]# 
```

## tune2fs
```
作用：调整ext系列的文件系统的相关属性。

选项：
-c：设置最大挂载次数，当达到最大挂载次数后，将会被e2fsck进行文件系统检查。如果设置为0或者是-1，将忽略检查。
-C：设置已经挂载了多少次。当该值设置的数大于-c选项设置的值，则在下一次重启时，将会进行文件系统检查。
-i：设置两次文件系统检查的最大时间间隔，单位可以是d(天)、m(月)、w(周)，0表示关闭该行为。
-l：列出指定文件系统的超级块信息。等同于dumpe2fs -h选项。
-L：设置文件系统的卷标。
-m：设置为超级管理员账户保留的block的百分比。
-o：指定挂载选项，常用的只有一个acl。
-r：设置保留的块的个数。
-u：设置谁可以使用保留的块。
-U：设置UUID


示例1：设置卷标
[root@vm10 tmp]# e2label /dev/sdb1
data1
[root@vm10 tmp]# blkid -s LABEL -o value /dev/sdb1 
data1
[root@vm10 tmp]# tune2fs -L 'new-data1' /dev/sdb1
tune2fs 1.41.12 (17-May-2010)
[root@vm10 tmp]# blkid -s LABEL -o value /dev/sdb1 
new-data1
[root@vm10 tmp]# e2label /dev/sdb1
new-data1
[root@vm10 tmp]# 


示例2：关闭文件系统检查
[root@vm10 tmp]# tune2fs -c 0 -i 0 /dev/sdb1
tune2fs 1.41.12 (17-May-2010)
Setting maximal mount count to -1
Setting interval between checks to 0 seconds
[root@vm10 tmp]# 

```

## dumpe2fs
```
作用：显示ext系列文件系统的信息。

选项：
-h：仅仅显示超级块的信息。
```

## e2fsck
```
作用：对ext系列文件系统进行检查。

选项：
-b：指定备份超级块的位置。通常用于当主超级块损坏时，用于修复超级块。备份的超级块位置依赖于文件系统的块大小，1k的块大小，备份的超级块位于8193, 2k的块大小，备份的超级块位于16384， 4k的块大小，备份的超级块位于32768. 也可以使用mke2fs -n选项找到备份的超级块位置。
-f：强制进行文件系统检查，即使文件系统是clean的。
-p：自动的修复文件系统。

说明：-b选项很重要，用于超级块修复。
```

## 设备挂载
```
格式：mount  选项 设备  挂载点

直接使用mount命令，可以查看已经挂载的设备。

说明：
设备可以是如下几种方式：
  设备文件：如/dev/sdb1
  卷标：LABEL="label-name"
  UUID：UUID="uuid"
挂载点是一个目录，该目录必须存在，并且该目录没有被其他进程使用，如果该目录不为空，则该目录下的内容会暂时隐藏。

选项：
-t：指定挂载设备的文件系统类型。通常不需要指定，mount会通过blkid命令获取文件系统的类型。
-a：挂载所有在/etc/fstab中没有挂载的设备。
--bind：重新挂载一个目录到另一个目录。格式为：--bind  olddir newdir
-n：挂载信息不写入到/etc/mtab文件中
-L：使用LABEL的方式挂载文件系统。
-U：使用UUID的方式挂载文件系统。
-o：指定额外的挂载选项。
    async：数据异步写入磁盘。一般为这种模式。
    sync：数据同步写入磁盘。
    atime：更新文件的访问时间。
    noatime：不更新文件的访问时间。
    auto：可以使用-a选项自动挂载。
    noauto：不能使用-a选项自动挂载。
    defaults：默认挂载选项。有：rw、suid、dev、exec、auto、nouser、async、realtime。
    dev：允许该文件系统解释设备文件（块设备文件或字符设备文件）。
    nodev：不允许该文件系统解释设备文件（块设备文件或字符设备文件）。
    exec：允许在该文件系统上执行二进制程序。
    noexec：不允许在该文件系统上执行二进制程序。
    _netdev：挂载网络设备。可以防止系统一直尝试挂载。
    suid：允许设置了suid或者是sgid的文件或目录生效。
    nosuid：不允许设置了suid或者是sgid的文件或目录生效。
    ro：以只读的方式挂载。
    rw：以读写的方式挂载。
    remount：重新挂载该文件系统。
    user：允许普通用户挂载该文件系统。
    nouser：不允许普通用户挂载该文件系统。

  

示例1：使用-L和-U方式挂载
[root@vm10 ~]# mount -L new-data1 /mnt
[root@vm10 ~]# umount /mnt
[root@vm10 ~]# 
[root@vm10 ~]# mount -U $(blkid -o value -s UUID /dev/sdb1) /mnt


示例2：挂载ISO镜像文件
[root@vm10 ~]# mount -o loop /opt/centos.iso /mnt

示例3：挂载光盘
[root@vm10 ~]# mount /dev/cdrom /mnt

示例4：查看所有已经挂载的设备。mount、/etc/mtab、/proc/mounts
[root@vm10 ~]# mount
/dev/mapper/vg_root-root_lv on / type ext4 (rw)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
devpts on /dev/pts type devpts (rw,gid=5,mode=620)
tmpfs on /dev/shm type tmpfs (rw)
/dev/sda1 on /boot type ext4 (rw)
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)
/dev/sdb1 on /mnt type ext4 (rw,noexec,nodev)
[root@vm10 ~]# 
[root@vm10 ~]# 
[root@vm10 ~]# cat /proc/mounts 
rootfs / rootfs rw 0 0
proc /proc proc rw,relatime 0 0
sysfs /sys sysfs rw,relatime 0 0
devtmpfs /dev devtmpfs rw,relatime,size=107904k,nr_inodes=26976,mode=755 0 0
devpts /dev/pts devpts rw,relatime,gid=5,mode=620,ptmxmode=000 0 0
tmpfs /dev/shm tmpfs rw,relatime 0 0
/dev/mapper/vg_root-root_lv / ext4 rw,relatime,barrier=1,data=ordered 0 0
/proc/bus/usb /proc/bus/usb usbfs rw,relatime 0 0
/dev/sda1 /boot ext4 rw,relatime,barrier=1,data=ordered 0 0
none /proc/sys/fs/binfmt_misc binfmt_misc rw,relatime 0 0
/dev/sdb1 /mnt ext4 rw,nodev,noexec,relatime,barrier=1,data=ordered 0 0
[root@vm10 ~]# 
[root@vm10 ~]# cat /etc/mtab 
/dev/mapper/vg_root-root_lv / ext4 rw 0 0
proc /proc proc rw 0 0
sysfs /sys sysfs rw 0 0
devpts /dev/pts devpts rw,gid=5,mode=620 0 0
tmpfs /dev/shm tmpfs rw 0 0
/dev/sda1 /boot ext4 rw 0 0
none /proc/sys/fs/binfmt_misc binfmt_misc rw 0 0
/dev/sdb1 /mnt ext4 rw,noexec,nodev 0 0
[root@vm10 ~]# 

```
