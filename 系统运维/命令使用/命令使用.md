# seq命令
```text
语法格式：
seq [OPTION]... LAST
seq [OPTION]... FIRST LAST
seq [OPTION]... FIRST INCREMENT LAST

选项：
-w：等宽输出。
-s：指定输出分隔符。默认为换行
-f：以printf的格式输出。
```

```bash
示例1：
[root@vm10 tmp]# seq -f 'file%03g' -s ' ' 1 5
file001 file002 file003 file004 file005
[root@vm10 tmp]# 


示例2：
[root@vm10 tmp]# seq -w 5 5 15
05
10
15
[root@vm10 tmp]# 

示例3：
[root@vm10 tmp]# seq -w -s ' - ' 5 5 15
05 - 10 - 15
[root@vm10 tmp]# 
```

# nohup命令
```text
nohup可以将程序以忽略挂起信号的方式运行起来，被运行的程序的输出将不会显示到终端。通常情况下，当我们以后台的方式（&）运行一个程序，这个程序通常是和当前shell终端相关联的，当我们的shell终端非法关闭（如ssh远程登录断开），系统会向和该终端所关联的所有进程发送SIGHUP信号，如果进程无法处理该信号，则默认就是终止进程。当使用nohup运行程序时，如果和该进程相关的终端关闭后，则该进程的父进程自动和init进程相关联（init的进程ID为1），这样只有当系统重启时，该进程才会终止。

无论是否将nohup命令的输出重定向到终端，输出都会附加到当前目录下的nohup.out文件中，如果当前目录的nohup.out文件不可写，则将输出重定向到$HOME/nohup.out文件中。如果没有文件能创建或可以追加，则nohup后面的命令将不可执行。
```

```bash
示例1：
# nohup sh check_ssh_login.sh &

示例2：指定输出文件。
# nohup sh check_ssh_login.sh > test.txt 2>&1 &
```

# find文件查找
```text
find语法格式：
find 查找路径  查找标准  查找到以后的处理动作
说明：
查找路径：默认为当前目录。
查找标准：默认为指定路径下的所有文件。
处理动作：默认为显示。

查找标准有：
-name 'filename'：根据文件名查找，精确查找。区分大小写。
-iname 'filename'：文件名匹配不区分大小写。
    文件名通配符：
     *：匹配任意长度的任意字符。
     ?：匹配任意一个字符。
     []：匹配括号中的任意一个字符。

-regex：使用正则表达式匹配文件名，区分大小写。
-iregexp：使用正则表达式匹配文件名，不区分大小写。

-user：根据文件的拥有者进行查找。
-group：根据文件的属组进行查找。
-uid：根据uid查找。
-gid：根据gid查找。
-nouser：查找没有属主的文件。
-nogroup：查找没有属组的文件。

-type：根据文件类型查找。
    f:普通文件
    d:目录
    b:块设备文件
    c:字符设备文件
    s：socket文件
    p：pipe管道文件
    l：链接文件

-size [[+-]nk|M|G]：根据文件大小查找。如果没有跟上大小，则默认单位为字节。+：表示大于指定的单位，-：表示小于指定大小的文件。

组合条件：
    -a：与
    -o：或
    -not：非
    如果指定了多个找到文件，但是没有指定组合条件，则默认为-a。

-mtime [[+-]n]：修改时间，文件内容被修改
-ctime [[+-]n]：改变时间，文件属性被修改
-atime [[+-]n]：访问时间，文件被查看
上述n为天数。
 
-mmin [[+-]n]
-cmin [[+-]n]
-amin [[+-]n]
上述n表示的是分钟。
 
+n     for greater than n
-n     for less than n
n      for exactly n
说明：如果时间为+5，则表示5天/分钟前。如果为-5，则表示5天/分钟内，如果为5，则表示第五天/分钟这一天。
 
-perm MODE：根据文件的权限匹配。确切的匹配权限，必须为指定的权限。
-perm -MODE：mode中的所有权限位都必须要设置才满足条件。
-perm /MODE：mode中的任何一个权限位被设置都满足条件。
 
 
find的动作
-print：默认的动作。
-ls：类似于ls -l的形式显示每一个文件的详细信息。
-ok COMMAND {} \; ：要执行的动作，和-exec一样的。{}表示引用找到的文件。\;结束符，为固定格式。
-exec COMMAND {} \; ：要执行的动作。

说明：-ok和-exec的区别是，-ok需要对每一个动作进行确认，-exec不需要确认。
```

# FACL(Filesystem Access Control List)
```text
setfacl: 设置文件或目录的ACL信息

说明：当文件具有扩展的属性时，使用ls -l列出文件的权限时，会看到有个加号（+）

选项：
-m：设置额外的ACL信息。
    u:USER:perm
    g:GROUP:perm
    o:OTHER:perm
    m:MASK
-x：取消设置额外的ACL信息。
    u:USER
    g:GROUP
    o:OTHER
    m:MASK

设置默认的ACL（只能用于目录），当为目录设置ACL时，在该目录下创建的文件自动会继承目录的ACL信息。
    d:u:USER:perm
    d:g:GROUP:perm

-b：移除所有的扩展ACL规则。
-k：移除默认的ACL规则。

-R：递归对所有文件及目录进行设置。
--restore=file：对ACL进行恢复。（备份可以用getfacl -R）

getfacl：获取文件或目录的ACL信息
    
-R：对acl进行备份。

```


```bash
示例1：设置facl
[root@vm10 tmp]# setfacl -m u:felix:rw- check_ssh_login.sh 
[root@vm10 tmp]# getfacl check_ssh_login.sh
# file: check_ssh_login.sh
# owner: root
# group: root
user::rw-
user:felix:rw-
group::r--
mask::rw-
other::r--

[root@vm10 tmp]#

示例2：取消设置
[root@vm10 tmp]# setfacl -x u:felix check_ssh_login.sh
[root@vm10 tmp]# getfacl check_ssh_login.sh
# file: check_ssh_login.sh
# owner: root
# group: root
user::rw-
group::r--
mask::r--
other::r--

[root@vm10 tmp]# 

示例3：acl备份和恢复
[root@vm10 tmp]# setfacl -m u:felix:rwx nohup.out 
[root@vm10 tmp]# getfacl nohup.out 
# file: nohup.out
# owner: root
# group: root
user::rw-
user:felix:rwx
group::---
mask::rwx
other::---

[root@vm10 tmp]# getfacl -R nohup.out > acl_backup.txt
[root@vm10 tmp]# setfacl -b nohup.out 
[root@vm10 tmp]# getfacl nohup.out 
# file: nohup.out
# owner: root
# group: root
user::rw-
group::---
other::---

[root@vm10 tmp]# setfacl --restore=acl_backup.txt 
[root@vm10 tmp]# getfacl nohup.out 
# file: nohup.out
# owner: root
# group: root
user::rw-
user:felix:rwx
group::---
mask::rwx
other::---

[root@vm10 tmp]# 

```

# df(显示磁盘空间的使用情况)
```text
选项：
-a：显示所有的文件系统，包括伪文件系统。
-h：以人类可读的方式显示文件大小。
-i：显示inode的使用情况
-T：显示文件系统类型。
-P：使用POSIX风格的输出。
```

# mknod(创建一个设备文件)
```text
设备文件介绍

设备文件分为：块设备(b)、字符设备(c)。每一个设备文件都有Major(主设备号)和Minor(次设备号)。Major代表的是不同类型的设备，Minor代表的是同一类型的多个设备。所有的设备文件都位置/dev目录下。

mknod是用于创建一个块设备文件或字符设备文件。

语法格式：mknod 选项  NAME TYPE  [MAJOR MINOR]
选项：
-m：设置权限模式。类似于chmod。

NAME：表示要创建的设备的文件名。
TYPE：表示要创建的设备类型。b表示块设备文件，c表示字符设备文件
MAJOR：指定设备文件的主设备号。
MINOR：指定设备文件的次设备号。

```
```bash
示例1：
[root@vm10 tmp]# mknod -m 660 /dev/sda100 b 8 100
[root@vm10 tmp]# ls -l /dev/sda100
brw-rw---- 1 root root 8, 100 Aug 12 13:49 /dev/sda100
[root@vm10 tmp]# chown root:disk /dev/sda100
[root@vm10 tmp]# ls -l /dev/sda100
brw-rw---- 1 root disk 8, 100 Aug 12 13:49 /dev/sda100
[root@vm10 tmp]# 

示例2：给终端发送信息
查看当前终端：tty

[root@vm10 tmp]# cat >> /dev/pts/1 << EOF
你是谁？
为什么在我的系统上
请退出
谢谢
EOF
[root@vm10 tmp]# 

```

# 磁盘相关的命令
## 磁盘分区命令
```text
磁盘分区：fdisk和parted

fdisk命令使用：fdisk /dev/sdb
常用的fdisk子命令如下：
a：设置可引导标记
d：删除一个分区
p：查看分区信息
n：新建一个分区
m：查看帮助信息
l：列出磁盘分区类型
t：修改磁盘分区类型
q：不保存退出
w：保存退出

当使用fdisk命令分区后，操作系统的内核并没有识别出这个新的分区，解决方法如下：
1. 重启系统。
2. 使用partprobe命令，让操作系统内核重读分区表。如果报错就用partx
3. 使用partx命令。

查看内核识别出的分区信息：/proc/partitions 
[root@vm10 ~]# cat /proc/partitions 
major minor  #blocks  name

   8        0   20971520 sda
   8        1     204800 sda1
   8        2   20765696 sda2
   8       16   10485760 sdb
 253        0   18665472 dm-0
 253        1    2097152 dm-1
[root@vm10 ~]# 
```

## partx(让内核重读分区表)
```text
partx：用来告诉内核当前磁盘分区情况。和fdisk不一样。
语法：partx 选项 [partition] wholedisk

选项：
-a：添加指定的磁盘分区或者是读整个硬盘，添加所有分区。
-d：删除指定分区或者所有分区。
-l：列出磁盘分区。
```

```bash
示例：
注意：内核必须要识别出新的分区，才能够格式化

1. 使用fdisk /dev/sdb创建了3个分区。
[root@vm10 ~]# fdisk -l /dev/sdb

Disk /dev/sdb: 10.7 GB, 10737418240 bytes
255 heads, 63 sectors/track, 1305 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x4b81ea63

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1         132     1060258+  83  Linux
/dev/sdb2             133         264     1060290   83  Linux
/dev/sdb3             265         396     1060290   83  Linux
[root@vm10 ~]# 

2. 查看内核识别出的分区信息
[root@vm10 ~]# cat /proc/partitions 
major minor  #blocks  name

   8        0   20971520 sda
   8        1     204800 sda1
   8        2   20765696 sda2
   8       16   10485760 sdb
 253        0   18665472 dm-0
 253        1    2097152 dm-1
[root@vm10 ~]# 

3. 让内核重读分区表
[root@vm10 ~]# partx -a /dev/sdb
[root@vm10 ~]# 

4. 查看内核识别出的分区信息
[root@vm10 ~]# cat /proc/partitions 
major minor  #blocks  name

   8        0   20971520 sda
   8        1     204800 sda1
   8        2   20765696 sda2
   8       16   10485760 sdb
   8       17    1060258 sdb1
   8       18    1060290 sdb2
   8       19    1060290 sdb3
 253        0   18665472 dm-0
 253        1    2097152 dm-1
[root@vm10 ~]# 

已经识别出来新创建的3个分区。

5. 格式化
[root@vm10 ~]# mkfs -t ext4 /dev/sdb1
mke2fs 1.41.12 (17-May-2010)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
66384 inodes, 265064 blocks
13253 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=272629760
9 block groups
32768 blocks per group, 32768 fragments per group
7376 inodes per group
Superblock backups stored on blocks: 
    32768, 98304, 163840, 229376

Writing inode tables: done                            
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 26 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
[root@vm10 ~]# 

6. 挂载
[root@vm10 ~]# mkdir /mount-test
[root@vm10 ~]# mount /dev/sdb1 /mount-test/
[root@vm10 ~]# cd /mount-test/
[root@vm10 mount-test]# ls
lost+found
[root@vm10 mount-test]# df -h
Filesystem                   Size  Used Avail Use% Mounted on
/dev/mapper/vg_root-root_lv   18G  1.3G   16G   8% /
tmpfs                        116M     0  116M   0% /dev/shm
/dev/sda1                    194M   29M  155M  16% /boot
/dev/sdb1                   1020M   34M  935M   4% /mount-test
[root@vm10 mount-test]# 

```

## 